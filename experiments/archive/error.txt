11: stop(substr(piece, 12, nchar(piece) - 13), call. = FALSE)
10: encall(self$r.session, vals, n.objectives, still.needs.proposition, 
        par.set, minimize, design, learner, on.surrogate.error, expr = {
            control <- constructMBOControl(vals = vals, n.objectives = n.objectives, 
                on.surrogate.error = on.surrogate.error)
            persistent$opt.state <- mlrMBO::initSMBO(control = control, 
                par.set = par.set, minimize = minimize, design = design, 
                learner = if (!is.null(learner)) 
                    makeCapsuledLearner(learner))
            proposition <- NULL
            if (still.needs.proposition) {
                proposition <- mlrMBO::proposePoints(persistent$opt.state)
                proposition$prop.points <- repairParamDF(ParamHelpers::getParamSet(persistent$opt.state$opt.problem$fun), 
                    proposition$prop.points)
            }
            persistent$design <- proposition$prop.points
            proposition
        })
9: .__OptimizerInterMBO__.optimize(self = self, private = private, 
       super = super, instance = instance)
8: private$.optimize(inst)
7: doTryCatch(return(expr), name, parentenv, handler)
6: tryCatchOne(expr, names, parentenv, handlers[[1L]])
5: tryCatchList(expr, classes, parentenv, handlers)
4: tryCatch({
       private$.optimize(inst)
   }, terminated_error = function(cond) {
   })
3: optimize_default(inst, self, private)
2: .__Optimizer__optimize(self = self, private = private, super = super, 
       inst = inst)
1: optimizer$optimize(ins)
